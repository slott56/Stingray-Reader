<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. Sheet Module – Sheet and Row Access &mdash; The Stingray Schema-Based File Reader</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '4.4.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="The Stingray Schema-Based File Reader" href="index.html" />
    <link rel="next" title="6. Schema Package – Schema and Attribute Definitions" href="schema.html" />
    <link rel="prev" title="4. Cell Module – Data Element Containers and Conversions" href="cell.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="schema.html" title="6. Schema Package – Schema and Attribute Definitions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cell.html" title="4. Cell Module – Data Element Containers and Conversions"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">The Stingray Schema-Based File Reader</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-sheet">
<span id="sheet-module-sheet-and-row-access"></span><span id="sheets"></span><h1>5. Sheet Module &#8211; Sheet and Row Access<a class="headerlink" href="#module-sheet" title="Permalink to this headline">¶</a></h1>
<p>A <em>Sheet</em> is a generator
of <em>Row</em> objects.  A <em>Row</em> is a sequence of <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> instances, identified by position.</p>
<p>We have three variations on <a class="reference internal" href="#sheet.Sheet" title="sheet.Sheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Sheet</span></tt></a>.</p>
<ul class="simple">
<li>A simple <a class="reference internal" href="#sheet.Sheet" title="sheet.Sheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Sheet</span></tt></a>  lacks a schema.
(This corresponds with <tt class="xref py py-func docutils literal"><span class="pre">csv.reader()</span></tt>.)
For workbooks with a well-known physical format, the schema can be optional.
Each <a class="reference internal" href="#sheet.Row" title="sheet.Row"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Row</span></tt></a> object can be built eagerly and accessed
by position.</li>
<li>A sheet with a schema.  There are two variations.<ul>
<li><a class="reference internal" href="#sheet.EmbeddedSchemaSheet" title="sheet.EmbeddedSchemaSheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.EmbeddedSchemaSheet</span></tt></a> contains a schema.
This could be a simple as column titles in the first row.
(This corresponds to <tt class="xref py py-class docutils literal"><span class="pre">csv.DictReader</span></tt>.)
Or it could be considerably more complex.</li>
<li><a class="reference internal" href="#sheet.ExternalSchemaSheet" title="sheet.ExternalSchemaSheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.ExternalSchemaSheet</span></tt></a> requires an external schema.
This schema may be simply a list of column titles supplied externally.
More often, the schema is a complete physical format description for
Fixed or COBOL format files.</li>
</ul>
</li>
</ul>
<p>A known physical format (like a workbook) can build <a class="reference internal" href="#sheet.Row" title="sheet.Row"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Row</span></tt></a> objects eagerly with or without a schema.</p>
<p>In the case of COBOL and fixed-format files, however, a <a class="reference internal" href="#sheet.Row" title="sheet.Row"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Row</span></tt></a>
cannot be built eagerly.  It must be a lazy
object which only builds <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> as needed.
See <a class="reference internal" href="cobol.html#cobol"><em>The COBOL Package</em></a> for details.</p>
<div class="section" id="get-embedded-schema-use-case">
<h2>5.1. Get Embedded Schema Use Case<a class="headerlink" href="#get-embedded-schema-use-case" title="Permalink to this headline">¶</a></h2>
<p>For an <a class="reference internal" href="#sheet.EmbeddedSchemaSheet" title="sheet.EmbeddedSchemaSheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.EmbeddedSchemaSheet</span></tt></a>, the application (or Workbook) must
do a three-step dance to get the schema that is embedded in the sheet.</p>
<ol class="arabic simple">
<li>Build a <a class="reference internal" href="#sheet.EmbeddedSchemaSheet" title="sheet.EmbeddedSchemaSheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.EmbeddedSchemaSheet</span></tt></a> with an
&#8220;embedded schema loader&#8221; class.  (For example, <a class="reference internal" href="schema_loader.html#schema.loader.HeadingRowSchemaLoader" title="schema.loader.HeadingRowSchemaLoader"><tt class="xref py py-class docutils literal"><span class="pre">schema.loader.HeadingRowSchemaLoader</span></tt></a>.)
The loader partitions rows into two sets: header and data.</li>
<li>Load the schema from the sheet.
The <a class="reference internal" href="#sheet.Sheet" title="sheet.Sheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Sheet</span></tt></a> will build an object of the loader class and use it to
gather the schema information.
The schema loading may involve skipping irrelevant rows or
combining multi-line headings or anything else required to parse the sheet.</li>
<li>Get the rows from the sheet.
This will, also, invoke the attached loader to filter rows so that the header is not seen as data.</li>
</ol>
<pre class="literal-block">
with <em>open</em> as wb:
    sheet = EmbeddedSchemaSheet( workbook, 'Sheet1', HeadingRowSchemaLoader )
    counts= process_sheet( sheet )
    pprint.pprint( counts )
</pre>
</div>
<div class="section" id="get-external-schema-use-case">
<h2>5.2. Get External Schema Use Case<a class="headerlink" href="#get-external-schema-use-case" title="Permalink to this headline">¶</a></h2>
<p>For an <a class="reference internal" href="#sheet.ExternalSchemaSheet" title="sheet.ExternalSchemaSheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.ExternalSchemaSheet</span></tt></a>, the application (or Workbook)
must do a four-step dance to get the schema.</p>
<ol class="arabic simple">
<li>Build a schema loader.
This loader will require a source workbook, sheet name and a reader object.</li>
<li>Get the Schema object from the loader.</li>
<li>Build a <a class="reference internal" href="#sheet.ExternalSchemaSheet" title="sheet.ExternalSchemaSheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.ExternalSchemaSheet</span></tt></a> with the Schema object.</li>
<li>Get the rows from the sheet.</li>
</ol>
<p>And yes, the external source, is another
spreadsheet!  Worse, the external source could be a fixed file or workbook
for which a meta-schema is required to read the schema.</p>
<pre class="literal-block">
with <em>open schema</em> as swb:
    esl = ExternalSchemaLoader( swb, sheet_name='Schema' )
    schema = esl.load()
with <em>open data</em> as wb:
    sheet = ExternalSchemaSheet( wb, 'Sheet1', schema )
    counts= process_sheet( sheet )
    pprint.pprint( counts )
</pre>
</div>
<div class="section" id="get-rows-use-case">
<h2>5.3. Get Rows Use Case<a class="headerlink" href="#get-rows-use-case" title="Permalink to this headline">¶</a></h2>
<p>The essential job of a <a class="reference internal" href="#sheet.Sheet" title="sheet.Sheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Sheet</span></tt></a> is to produce <a class="reference internal" href="#sheet.Row" title="sheet.Row"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Row</span></tt></a> instances.
A row is a sequence of <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> instances.</p>
<p>Note that <tt class="xref py py-mod docutils literal"><span class="pre">csv</span></tt> is eager about building a row from the source data.
This isn&#8217;t universally appropriate.  COBOL files require lazy construction
of the row&#8217;s cells.</p>
<p>A <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><tt class="xref py py-class docutils literal"><span class="pre">schema.Schema</span></tt></a> can transform a sequence row into a dictionary row
or a named tuple row.
The <tt class="xref py py-attr docutils literal"><span class="pre">schema.Attribute.name</span></tt> becomes the key for this row-as-dictionary.</p>
<p>We specifically delegate the row-as-dictionary interpretation to the <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><tt class="xref py py-class docutils literal"><span class="pre">schema.Schema</span></tt></a>,
and avoid doing it in the <a class="reference internal" href="#sheet.Sheet" title="sheet.Sheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Sheet</span></tt></a>.  This is because most
workbook schemata are flat.  However, a COBOL schema can have a very complex
structure, making the row-as-dictionary too simplistic to be useful.</p>
<p>As noted above, there are two candidate implementations of a Row.</p>
<ul class="simple">
<li><strong>Eager</strong>.  Appropriate for most (but not all) Physical Formats.  The
idea is to apply the schema immediately to create the row as a
tuple of cells.  <tt class="xref py py-mod docutils literal"><span class="pre">csv</span></tt> does this, and it can be applied to
other workbook formats.  It can be applied to simple, flat
Fixed format files.</li>
<li><strong>Lazy</strong>.  This is more appropriate for Fixed format files and COBOL format
files.  Specifically, the data conversion, redefines and repeating group
issues force us to wait for cell access rather than immediately create all
possible cells.  Indeed, for  COBOL files with REDEFINES definitions,
some of the cells cannot be built eagerly; application logic must determine
which attributes are valid or invalid.</li>
</ul>
<p>Note that the API is the same. The implementation differs.</p>
<p>Here&#8217;s our prototypical code.</p>
<pre class="literal-block">
def process_sheet( sheet ):
    counts= defaultdict( int )
    for row in sheet.rows():
        #<em>row is a sequence of</em> Cell <em>instances</em>
        print( repr(c) for c in row )
        counts['read'] += 1
    return counts
</pre>
<p>Ultimately, the sequence nature of a row is unsatisfying.   We&#8217;ll have to
wait until <a class="reference internal" href="schema.html#schema"><em>Schema Package &#8211; Schema and Attribute Definitions</em></a> to extend this into something useful.</p>
</div>
<div class="section" id="sheet-identification">
<h2>5.4. Sheet Identification<a class="headerlink" href="#sheet-identification" title="Permalink to this headline">¶</a></h2>
<p>For CSV and TAB files, as well as COBOL and Flat files, there is one anonymous
&#8220;sheet&#8221; that is the entire workbook.</p>
<p>For XLS, XLSX, and ODS formats, however, there are sheets within the workbook.</p>
<p>For Numbers, there are &#8220;pages&#8221; or &#8220;workspaces&#8221; that have multiple tables. Each
Numbers <strong>table</strong> is &#8211; effectively &#8211; a <a class="reference internal" href="#sheet.Sheet" title="sheet.Sheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Sheet</span></tt></a>. The
intermediate organization level, &#8220;workspace&#8221;, is an additional detail.</p>
<p>We handle this in the following way.</p>
<ul class="simple">
<li>One anonymous sheet has a name either of <tt class="docutils literal"><span class="pre">None</span></tt> or the basename of the file.</li>
<li>Simple sheets have names which are simple strings.</li>
<li>Numbers workspaces with sheets have names which are two-tuples of
workspace (&#8220;sheet&#8221;) and table name.</li>
</ul>
</div>
<div class="section" id="model">
<h2>5.5. Model<a class="headerlink" href="#model" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none"><div class="highlight"><pre>http://yuml.me/diagram/scruffy;dir:td/class/
#sheet,
[Workbook]&lt;&gt;-n[Sheet],
[Sheet]&lt;&gt;-n[Row],
[Row]^[LazyRow],
[LazyRow]-gets-&gt;[Workbook],
[Sheet]^[EmbeddedSchemaSheet],
[Sheet]^[ExternalSchemaSheet],
[EmbeddedSchemaSheet]-&gt;[SchemaLoader].
</pre></div>
</div>
<img alt="_images/sheet.png" src="_images/sheet.png" />
</div>
<div class="section" id="overheads">
<h2>5.6. Overheads<a class="headerlink" href="#overheads" title="Permalink to this headline">¶</a></h2>
<p>Sheet and Row are essentially lazy sequences.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;stingray.sheet -- Defines Row as  a collection of Cells and Sheet as a collection of Rows.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Sequence</span>
</pre></div>
</div>
<p>There are two &#8220;implicit&#8221; dependencies, also.
A row depends on details of an <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute</span></tt></a> and a <a class="reference internal" href="workbook/base.html#workbook.Workbook" title="workbook.Workbook"><tt class="xref py py-class docutils literal"><span class="pre">workbook.Workbook</span></tt></a>.
However, there&#8217;s no real need to present a formal import for this.
The Attribute and Workbook are simply opaque
objects passed around as arguments.</p>
</div>
<div class="section" id="sheet-class">
<h2>5.7. Sheet Class<a class="headerlink" href="#sheet-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sheet.Sheet">
<em class="property">class </em><tt class="descclassname">sheet.</tt><tt class="descname">Sheet</tt><a class="headerlink" href="#sheet.Sheet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A <a class="reference internal" href="#sheet.Sheet" title="sheet.Sheet"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Sheet</span></tt></a> is an iterator over the rows of data in a workbook.
Subclasses implement different bindings for the sheet&#8217;s schema information.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Sheet</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;An iterator over rows.</span>
<span class="sd">        A binding to a workbook.</span>
<span class="sd">        A subclass of Sheet will be bound to a schema.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">sheet_name</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">sheet_name</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;{0}({1!r},{2!r})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__qualname__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">rows</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate through the rows of this sheet.</span>
<span class="sd">        This is a convenient interface for ``self.workbook.rows_of(self)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="o">.</span><span class="n">rows_of</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="row-class">
<h2>5.8. Row Class<a class="headerlink" href="#row-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sheet.Row">
<em class="property">class </em><tt class="descclassname">sheet.</tt><tt class="descname">Row</tt><a class="headerlink" href="#sheet.Row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A single row in Sheet; a sequence of <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> instances.</p>
<p>A Sheet produces this simple row-as-list.  A Schema can transform this
into row-as-dict or some even more elaborate structure.</p>
<p>A row depends on details of an <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute</span></tt></a>
and a <a class="reference internal" href="workbook/base.html#workbook.Workbook" title="workbook.Workbook"><tt class="xref py py-class docutils literal"><span class="pre">workbook.Workbook</span></tt></a>.
This feels circular, but doesn&#8217;t present any real problems.</p>
<p>The <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> conversions are handled by the Workbook.
Some Workbooks have cell content identified by position.
Some Workbooks have cell content identified by size, offset and encoding.
Therefore, we must provide the Attribute details to the Workbook
to get the Cell&#8217;s value.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Row</span><span class="p">(</span> <span class="n">Sequence</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Eager Row: a tuple of Cell values.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">sheet</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build another Row.</span>

<span class="sd">        :param sheet: the containing sheet.</span>
<span class="sd">        :param *data: the various Cell values in this row</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">=</span> <span class="n">sheet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">=</span> <span class="n">data</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a specific cell, based on a schema Attribute.</span>

<span class="sd">        :param attribute: The attribute&#39;s value to return.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">workbook</span><span class="o">.</span><span class="n">row_get</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">cell</span> <span class="p">):</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span> <span class="n">cell</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">index</span> <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<p>To approach the <tt class="xref py py-class docutils literal"><span class="pre">csv.DictReader</span></tt> API (without the eager processing),
we need make the <tt class="docutils literal"><span class="pre">Row</span></tt> API slightly more fluent with a <tt class="docutils literal"><span class="pre">by_name()</span></tt>
method.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">by_name</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="p">):</span>
    <span class="n">attr</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span> <span class="n">attr</span> <span class="p">)</span>
</pre></div>
</div>
<p>Note that the presumption in this interface is that the Attribute is
sufficiently detailed to specify a single <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a>.
For non-COBOL workbooks, this is perfectly true.</p>
<p>For COBOL, however, there are groups and occurs clauses, meaning that a single Attribute can
represent multiple <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> instances.
Which one do we mean?  And how do we specify this selection?</p>
<ul>
<li><p class="first">The <tt class="xref py py-meth docutils literal"><span class="pre">sheet.Row.cell()</span></tt> method can return a structure with all the values.
Ordinary Python can then pick apart the instances.
This requires working up the DDE hierarchy to locate all of the applicable
&#8220;occurs&#8221; by to construct the proper dimensionality of an attribute.</p>
<p>It also means getting all of the values to create a tuple or nested
tuple-of-tuple structure for the various dimensions.</p>
</li>
<li><p class="first">The <tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute.index</span></tt> method
selects data from the row in the workbook.  This applies the indices
to the Attribute to compute the required offset into the source data.</p>
</li>
</ul>
<dl class="class">
<dt id="sheet.LazyRow">
<em class="property">class </em><tt class="descclassname">sheet.</tt><tt class="descname">LazyRow</tt><a class="headerlink" href="#sheet.LazyRow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>When we can&#8217;t eagerly build all <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> instances for a given
row, this class provides the proper API.</p>
<p>A COBOL REDEFINES clause may make the bytes invalid in all but one of the
aliases for an attribute.  Also, there&#8217;s no formal <tt class="docutils literal"><span class="pre">NULL</span></tt> value in COBOL, so
optional fields can have invalid data.</p>
<p>Further, we may have Occurs Depending On. This means we can&#8217;t set size and
offset until we can access actual data.</p>
<p>For these reasons, we have a <a class="reference internal" href="#sheet.LazyRow" title="sheet.LazyRow"><tt class="xref py py-class docutils literal"><span class="pre">sheet.LazyRow</span></tt></a>, which conforms to the
interface for a <a class="reference internal" href="#sheet.Row" title="sheet.Row"><tt class="xref py py-class docutils literal"><span class="pre">Row</span></tt></a>, but isn&#8217;t an actual sequence. No data is
processed until the <tt class="xref py py-meth docutils literal"><span class="pre">LazyRow.__getitem__()</span></tt> method is used.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LazyRow</span><span class="p">(</span> <span class="n">Sequence</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lazy Row: a tuple-like sequence of Cell values.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">sheet</span><span class="p">,</span> <span class="o">**</span><span class="n">state</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build another Row.</span>

<span class="sd">        :param sheet: the containing sheet.</span>
<span class="sd">        :param **state: worksheet-specific state value to save.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">=</span> <span class="n">sheet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="o">=</span> <span class="n">state</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;LazyRow(sheet={0!r}, state={1!r})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a specific cell, based on a schema Attribute.</span>

<span class="sd">        :param attribute: The attribute&#39;s value to return.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">workbook</span><span class="o">.</span><span class="n">row_get</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">schema</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">workbook</span><span class="o">.</span><span class="n">row_get</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">None</span>
    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">cell</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">schema</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">col</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">workbook</span><span class="o">.</span><span class="n">row_get</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">cell</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">index</span> <span class="p">):</span>
        <span class="n">attribute</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">workbook</span><span class="o">.</span><span class="n">row_get</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span> <span class="p">)</span>
</pre></div>
</div>
<p>To approach the <tt class="xref py py-class docutils literal"><span class="pre">csv.DictReader</span></tt> API (without the eager processing),
we can make the <tt class="docutils literal"><span class="pre">Row</span></tt> API slightly more fluent with a <tt class="docutils literal"><span class="pre">by_name()</span></tt>
method.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">by_name</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="p">):</span>
    <span class="n">attr</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span> <span class="n">attr</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="externalschemasheet-class">
<h2>5.9. ExternalSchemaSheet Class<a class="headerlink" href="#externalschemasheet-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sheet.ExternalSchemaSheet">
<em class="property">class </em><tt class="descclassname">sheet.</tt><tt class="descname">ExternalSchemaSheet</tt><a class="headerlink" href="#sheet.ExternalSchemaSheet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A Sheet with an external schema can be one of two kinds.</p>
<ul class="simple">
<li>A Sheet that doesn&#8217;t have row headers to embed the schema information.
In this case, an eager Workbook Row can create a sequence of <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> instances.
The Schema information can be associated by position.</li>
<li>A Sheet that is really a COBOL or Fixed format file.
In this case, the Workbook cannot create a sequence of <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> instances.
Instead, the Sheet (which has schema information) must
provide a LazyRow with deferred Cell conversions.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ExternalSchemaSheet</span><span class="p">(</span> <span class="n">Sheet</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A Sheet with an external Schema.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">sheet_name</span><span class="p">,</span> <span class="n">schema</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a sheet for processing.</span>

<span class="sd">        :param workbook: the containing workbook</span>
<span class="sd">        :param sheet_name: the specific sheet to locate within the Workbook</span>
<span class="sd">        :param schema: the :py:class:`schema.Schema` schema definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">sheet_name</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">=</span> <span class="n">schema</span>
    <span class="k">def</span> <span class="nf">rows</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate through the rows of this sheet.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="o">.</span><span class="n">rows_of</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="embeddedschemasheet-class">
<h2>5.10. EmbeddedSchemaSheet Class<a class="headerlink" href="#embeddedschemasheet-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sheet.EmbeddedSchemaSheet">
<em class="property">class </em><tt class="descclassname">sheet.</tt><tt class="descname">EmbeddedSchemaSheet</tt><a class="headerlink" href="#sheet.EmbeddedSchemaSheet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A sheet with an embedded schema must have a loader class provided.  The loader
is invoked to build a <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><tt class="xref py py-class docutils literal"><span class="pre">schema.Schema</span></tt></a> object.
It&#8217;s also used to return the rest of the rows; those that weren&#8217;t used to build the schema.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">EmbeddedSchemaSheet</span><span class="p">(</span> <span class="n">ExternalSchemaSheet</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A Sheet with a Schema embedded in it.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">sheet_name</span><span class="p">,</span> <span class="n">loader_class</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a sheet for processing.</span>

<span class="sd">        :param workbook: the containing workbook</span>
<span class="sd">        :param sheet_name: the specific sheet to locate within the Workbook</span>
<span class="sd">        :param loader_class: the :py:class:`schema.loader.SchemaLoader`</span>
<span class="sd">        schema loader to load the schema from the sheet.</span>

<span class="sd">        Apply the loader to the given sheet of the workbook to get schema</span>
<span class="sd">        and rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Sheet</span><span class="p">(</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">sheet_name</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loader</span> <span class="o">=</span> <span class="n">loader_class</span><span class="p">(</span> <span class="n">s</span> <span class="p">)</span>
        <span class="n">schema</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">schema</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">sheet_name</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">rows</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The parser will skip over the headers.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">rows</span><span class="p">()</span>
</pre></div>
</div>
<p>Since the rows are already properly encoded as <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> instances,
no further processing is required by the Sheet or the Loader.</p>
</div>
<div class="section" id="rows-of-a-sheet">
<h2>5.11. Rows of a Sheet<a class="headerlink" href="#rows-of-a-sheet" title="Permalink to this headline">¶</a></h2>
<p>Note that the <tt class="xref py py-mod docutils literal"><span class="pre">csv</span></tt> design pattern for each row involves two subclasses
with the same method names but different results.  One
returns a <tt class="docutils literal"><span class="pre">dict</span></tt> of cells, the other returns a <tt class="docutils literal"><span class="pre">list</span></tt> of cells.</p>
<p>The dict-based processing has the advantage of clarity.  It has the
disadvantage of not coping well with duplicate column names or data
which breaks first normal form.</p>
<p>Also, note that <tt class="xref py py-mod docutils literal"><span class="pre">csv</span></tt> does eager creation of each row.
The <tt class="xref py py-class docutils literal"><span class="pre">csv.DictReader</span></tt> does eager creation of a dictionary from each row.</p>
<p>We don&#8217;t follow the <tt class="xref py py-mod docutils literal"><span class="pre">csv</span></tt> design pattern.  Instead we do the following.</p>
<ul class="simple">
<li>A <a class="reference internal" href="#sheet.Row" title="sheet.Row"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Row</span></tt></a> can be a lazy sequence of <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> instances.</li>
<li>A <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><tt class="xref py py-class docutils literal"><span class="pre">schema.Schema</span></tt></a> must be used to fetch <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a>
instances from the <a class="reference internal" href="#sheet.Row" title="sheet.Row"><tt class="xref py py-class docutils literal"><span class="pre">sheet.Row</span></tt></a>.</li>
<li>To create dict-like access to Cell instances, the schema can be turned into a dictionary.
This &#8220;schema-as-dict&#8221; can then be used with a properly
lazy Row to create Cell instances.</li>
</ul>
<p>This lazy evaluation of a row that fetches data based on <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute</span></tt></a>
details  allows us to cope with COBOL <tt class="docutils literal"><span class="pre">REDEFINES</span></tt>.  It also allows us to cope
with the unfortunately common problem of duplicate column names in conventional
spreadsheets.</p>
<p>We can have application programming which looks like this to process rows in a number of ways.</p>
<p>Row as sequence is the default.</p>
<pre class="literal-block">
for row in sheet.rows():
    <em>Cell:</em> row[i]
    <em>Schema Attribute Name:</em> sheet.schema[i].name
</pre>
<p>Row as dict is a common alternative.  If we have unique column names in the schema,
We can than use application programming that looks like this.</p>
<pre class="literal-block">
schema_dict = dict( (a.name, a) for a in sheet.schema )
for row in sheet.rows():
    <em>Cell:</em> row.cell(schema_dict['name'])
    row_as_dict= dict(
        (a.name, row.cell(a)) for a in sheet.schema )
    <em>Cell:</em> row_as_dict['name']
</pre>
<p>This handles the COBOL case, where rows must be lazy.
This includes COBOL <tt class="docutils literal"><span class="pre">REDEFINES</span></tt> and occurs clauses.
This assures proper packed decimal conversion of redefined fields.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/Stingray_belon1553_small.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. Sheet Module &#8211; Sheet and Row Access</a><ul>
<li><a class="reference internal" href="#get-embedded-schema-use-case">5.1. Get Embedded Schema Use Case</a></li>
<li><a class="reference internal" href="#get-external-schema-use-case">5.2. Get External Schema Use Case</a></li>
<li><a class="reference internal" href="#get-rows-use-case">5.3. Get Rows Use Case</a></li>
<li><a class="reference internal" href="#sheet-identification">5.4. Sheet Identification</a></li>
<li><a class="reference internal" href="#model">5.5. Model</a></li>
<li><a class="reference internal" href="#overheads">5.6. Overheads</a></li>
<li><a class="reference internal" href="#sheet-class">5.7. Sheet Class</a></li>
<li><a class="reference internal" href="#row-class">5.8. Row Class</a></li>
<li><a class="reference internal" href="#externalschemasheet-class">5.9. ExternalSchemaSheet Class</a></li>
<li><a class="reference internal" href="#embeddedschemasheet-class">5.10. EmbeddedSchemaSheet Class</a></li>
<li><a class="reference internal" href="#rows-of-a-sheet">5.11. Rows of a Sheet</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="cell.html"
                        title="previous chapter">4. Cell Module &#8211; Data Element Containers and Conversions</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="schema.html"
                        title="next chapter">6. Schema Package &#8211; Schema and Attribute Definitions</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/sheet.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="schema.html" title="6. Schema Package – Schema and Attribute Definitions"
             >next</a> |</li>
        <li class="right" >
          <a href="cell.html" title="4. Cell Module – Data Element Containers and Conversions"
             >previous</a> |</li>
        <li><a href="index.html">The Stingray Schema-Based File Reader</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, S. Lott.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>