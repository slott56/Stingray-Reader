<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>10.2.3. COBOL Definitions Module – Handle COBOL DDE’s &mdash; The Stingray Schema-Based File Reader</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '4.4.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="The Stingray Schema-Based File Reader" href="index.html" />
    <link rel="up" title="10. The COBOL Package" href="cobol.html" />
    <link rel="next" title="11. The Stingray Developer’s Guide" href="developer.html" />
    <link rel="prev" title="10.2.2. COBOL Loader Module – Parse COBOL Source to Load a Schema" href="cobol_loader.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="developer.html" title="11. The Stingray Developer’s Guide"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cobol_loader.html" title="10.2.2. COBOL Loader Module – Parse COBOL Source to Load a Schema"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">The Stingray Schema-Based File Reader</a> &raquo;</li>
          <li><a href="cobol.html" accesskey="U">10. The COBOL Package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-cobol.defs">
<span id="cobol-definitions-module-handle-cobol-dde-s"></span><span id="cobol-defs"></span><h1>10.2.3. COBOL Definitions Module &#8211; Handle COBOL DDE&#8217;s<a class="headerlink" href="#module-cobol.defs" title="Permalink to this headline">¶</a></h1>
<p>This is a small set of class definitions and functions
that are used by <a class="reference internal" href="cobol_loader.html#module-cobol.loader" title="cobol.loader"><tt class="xref py py-mod docutils literal"><span class="pre">cobol.loader</span></tt></a> as well as
<a class="reference internal" href="cobol_init.html#module-cobol" title="cobol"><tt class="xref py py-mod docutils literal"><span class="pre">cobol</span></tt></a>.</p>
<p>The intent of this module is to avoid a few circular import dependencies.</p>
<div class="section" id="the-architecture-problem">
<h2>10.2.3.1. The Architecture Problem<a class="headerlink" href="#the-architecture-problem" title="Permalink to this headline">¶</a></h2>
<p>We have an issue of separation of three concerns:</p>
<ul class="simple">
<li>The underlying workbook and the parsing of CSV or XML or EBCDIC.
This is the Physical Format.</li>
<li>The logical layout or schema we&#8217;re imposing on the workbook&#8217;s data.</li>
<li>The process of loading a schema, possibly using a meta-workbook.
This includes the translation of COBOL notation into a useful schema.</li>
</ul>
<p>Except for COBOL, a schema depends on a meta-workbook via a schema loader.
But this is the limit of the relationship. We could say</p>
<div class="math">
<p><img src="_images/math/6fd69b85f7dc363bb3edb54afabe59250ccc871d.png" alt="S = L(w)"/></p>
</div><p>Or <tt class="docutils literal"><span class="pre">schema=</span> <span class="pre">loader(workbook)</span></tt>. This may involve a separate workbook file,
a separate sheet within a file or even just columns within
the current sheet.</p>
<p>For COBOL, we&#8217;d like to keep schema, schema loader and workbook separate, also,
even though COBOL code doesn&#8217;t depend on COBOL data files.
We&#8217;d still like to say <tt class="docutils literal"><span class="pre">schema=</span> <span class="pre">loader(cobol</span> <span class="pre">source)</span></tt>.</p>
<div class="math">
<p><img src="_images/math/4251c01e84eb8d27a7d786ef915ec8ccee584083.png" alt="S = L(c)"/></p>
</div><p>We can imagine that an application will import a workbook class and a schema loader class.
It will load the schema, then open the workbook using the schema.</p>
<p><strong>However</strong>.</p>
<p>A COBOL schema with an occurs depending on (i.e. a DDE with <tt class="docutils literal"><span class="pre">variably_located</span> <span class="pre">==</span> <span class="pre">True</span></tt>)
will have the schema depending on each row in addition to the overall loading.</p>
<p>We&#8217;re really taking about a Baseline Schema, <img class="math" src="_images/math/5b3062521e741f882bfb078eaf4d8fc1f347f925.png" alt="S_b"/>, and a Row-Level Schema, <img class="math" src="_images/math/69545b906f359eb9f8d4903659fb8480acd8dad4.png" alt="S_r"/>,
that is built by resolving any Occurs Depending On</p>
<div class="math">
<p><img src="_images/math/d08db6810c3fda292a645ed7e48c9ca640a09d23.png" alt="S_b = L(c)"/></p>
</div><div class="math">
<p><img src="_images/math/a882ec6c4f72ec794c6ce547215ea9f5fb32268c.png" alt="s_r = R( d, S_b )"/></p>
</div><p>We&#8217;ve changed <tt class="docutils literal"><span class="pre">schema_baseline=</span> <span class="pre">loader(cobol</span> <span class="pre">source)</span></tt> and then,
for each row, <tt class="docutils literal"><span class="pre">schema_row=</span> <span class="pre">setSizeAndOffset(data,</span> <span class="pre">schema_baseline)</span></tt>.</p>
<div class="section" id="where-to-recompute">
<h3>10.2.3.1.1. Where To Recompute<a class="headerlink" href="#where-to-recompute" title="Permalink to this headline">¶</a></h3>
<p>The fundamental issue is this: when can we recompute the offsets?</p>
<p>The choices for computing the offsets are these:</p>
<ul class="simple">
<li>At <tt class="xref py py-meth docutils literal"><span class="pre">COBOL_File.rows_of()</span></tt> time &#8211; eagerly, but in the wrong module.
See below.</li>
<li>At <tt class="xref py py-meth docutils literal"><span class="pre">COBOL_File.row_get()</span></tt> time &#8211; a bit more lazy, but still in the wrong
module, since it&#8217;s here, not in <a class="reference internal" href="cobol_loader.html#module-cobol.loader" title="cobol.loader"><tt class="xref py py-mod docutils literal"><span class="pre">cobol.loader</span></tt></a>.</li>
<li>In the application before doing any schema processing on a given row. Very lazy.
But now the application must be more deeply involved in ODO processing. The application
would do something like the following. Sadly, it has a line that&#8217;s easy to overlook.</li>
</ul>
<pre class="literal-block">
with open(&quot;xyzzy.cob&quot;) as source:
    dde_list, schema = COBOL_schema( source )
with stingray.cobol.Character_File( filename, schema=schema ) as wb:
    sheet= wb.sheet( filename )
    for row in sheet.rows():
        <strong>cobol.loader.setSizeAndOffset( dde_list[0] )</strong>
        dump( schema, row )
</pre>
</div>
<div class="section" id="the-module-dependency-problem">
<h3>10.2.3.1.2. The Module Dependency Problem<a class="headerlink" href="#the-module-dependency-problem" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#cobol.defs.Usage" title="cobol.defs.Usage"><tt class="xref py py-class docutils literal"><span class="pre">Usage</span></tt></a> class properly depends on <a class="reference internal" href="cobol_init.html#module-cobol" title="cobol"><tt class="xref py py-mod docutils literal"><span class="pre">cobol</span></tt></a>.
The <a class="reference internal" href="cobol_loader.html#cobol.loader.make_attr" title="cobol.loader.make_attr"><tt class="xref py py-func docutils literal"><span class="pre">cobol.loader.make_attr()</span></tt></a> function, also, properly depends on <a class="reference internal" href="cobol_init.html#module-cobol" title="cobol"><tt class="xref py py-mod docutils literal"><span class="pre">cobol</span></tt></a>.</p>
<p>The idea is that workbooks are more fundamental than schema. We might need to use
one workbook to build a schema to read another workbook. Schema are higher-level constructs.</p>
<p>We want to avoid any circular dependency between <a class="reference internal" href="cobol_loader.html#module-cobol.loader" title="cobol.loader"><tt class="xref py py-mod docutils literal"><span class="pre">cobol.loader</span></tt></a> referring
back to <a class="reference internal" href="cobol_init.html#module-cobol" title="cobol"><tt class="xref py py-mod docutils literal"><span class="pre">cobol</span></tt></a>.
The <tt class="xref py py-class docutils literal"><span class="pre">schema.RepeatingAttribute</span></tt> definition has a weak version of this undesirable.
dependency.  We finesse it
by defining a bunch of properties that exploit the underlying DDE details without
an explicit <tt class="docutils literal"><span class="pre">import</span></tt> of the DDE class.</p>
<p>To assure that <tt class="docutils literal"><span class="pre">cobol</span></tt> does not depend on <tt class="docutils literal"><span class="pre">cobol.loader</span></tt>,
we&#8217;d have the class  <tt class="xref py py-class docutils literal"><span class="pre">schema.RepeatingAttribute</span></tt> entirely built without
reference to the base DDE.
This, however, means that we would effectively clone
the hierarchical relationships into the <tt class="xref py py-class docutils literal"><span class="pre">schema.RepeatingAttribute</span></tt> objects.
Why bother?</p>
<p>If we extend <tt class="xref py py-meth docutils literal"><span class="pre">COBOL_File.rows_of()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">COBOL_File.row_get()</span></tt>, we
exacerbates the problem because it would introduce a circular <tt class="docutils literal"><span class="pre">import</span></tt>. This
would make <tt class="docutils literal"><span class="pre">cobol</span></tt> depend on <tt class="docutils literal"><span class="pre">cobol.loader</span></tt> explicitly.</p>
</div>
<div class="section" id="resolution">
<h3>10.2.3.1.3. Resolution<a class="headerlink" href="#resolution" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">setSizeAndOffset()</span></tt> function as well as a few other
post-processing functions belong in an intermediate module that both <tt class="docutils literal"><span class="pre">cobol</span></tt>
and <tt class="docutils literal"><span class="pre">cobol.loader</span></tt> depend on.</p>
<p>Specifically, Cell definitions, DDE definitions, and the related functions required
to build schema attributes from DDE&#8217;s.</p>
<p>That way, <tt class="docutils literal"><span class="pre">cobol</span></tt> can import <tt class="docutils literal"><span class="pre">cobol.defs.setSizeAndOffset</span></tt>.</p>
<p>Also, <tt class="docutils literal"><span class="pre">cobol.loader</span></tt> can import <tt class="docutils literal"><span class="pre">cobol.defs.DDE</span></tt>.</p>
<p>And <tt class="docutils literal"><span class="pre">cobol.RepeatingAttribute</span></tt> can depend on <tt class="docutils literal"><span class="pre">cobol.defs.DDE</span></tt>.</p>
</div>
</div>
<div class="section" id="overheads">
<h2>10.2.3.2. Overheads<a class="headerlink" href="#overheads" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;stingray.cobol.defs -- COBOL DDE and Tools.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">stingray.cell</span>
</pre></div>
</div>
<p>A module-level logger.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">logger</span><span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span> <span class="n">__name__</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="exception">
<h2>10.2.3.3. Exception<a class="headerlink" href="#exception" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cobol.defs.UnsupportedError">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">UnsupportedError</tt><a class="headerlink" href="#cobol.defs.UnsupportedError" title="Permalink to this definition">¶</a></dt>
<dd><p>A syntax which expresses an unsupported feature
of the COBOL language.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UnsupportedError</span><span class="p">(</span> <span class="ne">Exception</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A COBOL DDE has features not supported by this module.&quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The most important unsupported feature may be &#8220;separate signs.&#8221;  These may be
required for decoding bytes in some files.</p>
</div>
<div class="section" id="cell-subclasses-and-conversions">
<h2>10.2.3.4. Cell Subclasses and Conversions<a class="headerlink" href="#cell-subclasses-and-conversions" title="Permalink to this headline">¶</a></h2>
<p>Rather than tinker too much with the <a class="reference internal" href="cell.html#module-cell" title="cell"><tt class="xref py py-mod docutils literal"><span class="pre">cell</span></tt></a> module,
it seems better to introduce new <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> subclasses unique to COBOL, EBCIDC
and COMP-3 data.</p>
<p>There are three relevant features.</p>
<ul class="simple">
<li>Proper conversion from source characters or bytes.</li>
<li>Preservation of the source characters (or bytes) for creating
character-level (or byte-level) structured dumps of a record.</li>
<li>Preservation of the original DDE attributes, because there is so much
information required to interpret the bytes.</li>
</ul>
<p>Consequently, even the <a class="reference internal" href="cell.html#cell.TextCell" title="cell.TextCell"><tt class="xref py py-class docutils literal"><span class="pre">cell.TextCell</span></tt></a> must be extended to include
preservation of raw data.</p>
<p>Further, we have a distinction between text and numbers which are
&#8220;USAGE DISPLAY&#8221;.</p>
<div class="highlight-none"><div class="highlight"><pre>http://yuml.me/diagram/scruffy;/class/
#cobol.cell,
[TextCell]^[NumberCell],
[NumberCell]^[NumberDisplayCell],
[NumberCell]^[NumberCompCell],
[NumberCell]^[NumberComp3Cell],
[TextCell]^[ErrorCell],
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/cobol_cell.png"><img alt="_images/cobol_cell.png" src="_images/cobol_cell.png" style="width: 6in;" /></a>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>Non-Polymorphic.</p>
<p class="last">These classes are profound extensions to the base definitions of <a class="reference internal" href="cell.html#module-cell" title="cell"><tt class="xref py py-mod docutils literal"><span class="pre">cell</span></tt></a>.
They are not polymorphic with the base classes.
COBOL processing is not transparently identical to other workbook processing.</p>
</div>
<p>These cells are conventionally built by the the <a class="reference internal" href="cobol_init.html#cobol.COBOL_File" title="cobol.COBOL_File"><tt class="xref py py-class docutils literal"><span class="pre">cobol.COBOL_File</span></tt></a> version
of Workbook as a factory. These are rarely built any other way.</p>
<dl class="class">
<dt id="cobol.defs.TextCell">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">TextCell</tt><a class="headerlink" href="#cobol.defs.TextCell" title="Permalink to this definition">¶</a></dt>
<dd><p>A cell which contains COBOL Alphanumeric data.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TextCell</span><span class="p">(</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">TextCell</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A COBOL TextCell, usually Usage Display.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="o">=</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="n">text</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.NumberCell">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">NumberCell</tt><a class="headerlink" href="#cobol.defs.NumberCell" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an abstraction to simply hold all the standard conversions</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NumberCell</span><span class="p">(</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">NumberCell</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A COBOL number.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">to_int</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span> <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_float</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span> <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_decimal</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="bp">None</span> <span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    <span class="k">def</span> <span class="nf">to_str</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span> <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.NumberDisplayCell">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">NumberDisplayCell</tt><a class="headerlink" href="#cobol.defs.NumberDisplayCell" title="Permalink to this definition">¶</a></dt>
<dd><p>A COBOL numeric item with USAGE DISPLAY.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NumberDisplayCell</span><span class="p">(</span> <span class="n">NumberCell</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A COBOL Usage Display Numeric Cell.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="o">=</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="n">number_display</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.NumberCompCell">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">NumberCompCell</tt><a class="headerlink" href="#cobol.defs.NumberCompCell" title="Permalink to this definition">¶</a></dt>
<dd><p>A COBOL numeric item with USAGE COMPUTATIONAL.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NumberCompCell</span><span class="p">(</span> <span class="n">NumberCell</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A COBOL Usage COMP Numeric Cell.</span>
<span class="sd">    Three formats.  Half-word, whole-word and double-word.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="o">=</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="n">number_comp</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.NumberComp3Cell">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">NumberComp3Cell</tt><a class="headerlink" href="#cobol.defs.NumberComp3Cell" title="Permalink to this definition">¶</a></dt>
<dd><p>A COBOL numeric item with USAGE COMPUTATIONAL-3.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NumberComp3Cell</span><span class="p">(</span> <span class="n">NumberCell</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A COBOL Usage COMP-3 Numeric Cell..&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="o">=</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="n">number_comp3</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.ErrorCell">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">ErrorCell</tt><a class="headerlink" href="#cobol.defs.ErrorCell" title="Permalink to this definition">¶</a></dt>
<dd><p>A COBOL numeric item with invalid data.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ErrorCell</span><span class="p">(</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">ErrorCell</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A COBOL ErrorCell, bad data bytes with no relevant value.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">exception</span><span class="o">=</span><span class="bp">None</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="o">=</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exception</span><span class="o">=</span> <span class="n">exception</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;{0}({1!r}, {2!r})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exception</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="essential-class-definitions">
<h2>10.2.3.5. Essential Class Definitions<a class="headerlink" href="#essential-class-definitions" title="Permalink to this headline">¶</a></h2>
<p>The essential class definitions define the DDE we&#8217;re attempting to build.
We can  separated this structure into a few high-level subject areas:</p>
<ul class="simple">
<li><a class="reference internal" href="#usage-strategy-hierarchy">Usage Strategy Hierarchy</a> defines the various
kinds of USAGE options.</li>
<li><a class="reference internal" href="#allocation-strategy-hierarchy">Allocation Strategy Hierarchy</a> defines the relationships among DDE&#8217;s:
Predecessor/Successor, Group/Elementary or Redefines.</li>
<li><a class="reference internal" href="#occurs-strategy-hierarchy">Occurs Strategy Hierarchy</a> defines the Occurs options of
Default (no Occurs), simple Occurs, and more complex Occurs Depending On.</li>
<li>The <a class="reference internal" href="#dde-class">DDE Class</a> itself.</li>
</ul>
<div class="section" id="usage-strategy-hierarchy">
<h3>10.2.3.5.1. Usage Strategy Hierarchy<a class="headerlink" href="#usage-strategy-hierarchy" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#cobol.defs.Usage" title="cobol.defs.Usage"><tt class="xref py py-class docutils literal"><span class="pre">Usage</span></tt></a> class combines information in the picture, usage, sign and synchronized clauses.</p>
<p>The <strong>Strategy</strong> design pattern allows a DDE element to delegate
the <a class="reference internal" href="#cobol.defs.Usage.size" title="cobol.defs.Usage.size"><tt class="xref py py-meth docutils literal"><span class="pre">Usage.size()</span></tt></a> and <a class="reference internal" href="#cobol.defs.Usage.create_func" title="cobol.defs.Usage.create_func"><tt class="xref py py-meth docutils literal"><span class="pre">Usage.create_func()</span></tt></a> operations to this class.</p>
<p>The <a class="reference internal" href="#cobol.defs.Usage.size" title="cobol.defs.Usage.size"><tt class="xref py py-meth docutils literal"><span class="pre">Usage.size()</span></tt></a> method returns the number
of bytes used by the data element.</p>
<ul class="simple">
<li>For usage <tt class="docutils literal"><span class="pre">DISPLAY</span></tt>, the size is computed directly from the picture clause.</li>
<li>For usage <tt class="docutils literal"><span class="pre">COMP</span></tt>, the size is 2, 4 or 8 bytes based on the picture clause.</li>
<li>For usage <tt class="docutils literal"><span class="pre">COMP-3</span></tt>, the picture clause digits are packed two per byte
with an extra half-byte for sign information. This must be rounded up.
COMP-3 fields often have an odd number of digits to reflect this.</li>
</ul>
<p>The <a class="reference internal" href="#cobol.defs.Usage.create_func" title="cobol.defs.Usage.create_func"><tt class="xref py py-meth docutils literal"><span class="pre">Usage.create_func()</span></tt></a> method returns a <a class="reference internal" href="cell.html#cell.Cell" title="cell.Cell"><tt class="xref py py-class docutils literal"><span class="pre">cell.Cell</span></tt></a> type
that should be built from the raw bytes.</p>
<div class="highlight-none"><div class="highlight"><pre>http://yuml.me/diagram/scruffy;/class/
#cobol_loader_usage,
[RecordFactory]&lt;&gt;-[DDE],
[DDE]&lt;&gt;-[DDE],
[DDE]-[Usage],
[Usage]^[UsageDisplay],
[Usage]^[UsageComp]
[Usage]^[UsageComp3]
</pre></div>
</div>
<img alt="_images/cobol_usage.png" src="_images/cobol_usage.png" />
<dl class="class">
<dt id="cobol.defs.Usage">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">Usage</tt><a class="headerlink" href="#cobol.defs.Usage" title="Permalink to this definition">¶</a></dt>
<dd><p>The Usage class provides detailed representation and conversion support
for a given DDE. A <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute</span></tt></a> will refer to a
<a class="reference internal" href="#cobol.defs.DDE" title="cobol.defs.DDE"><tt class="xref py py-class docutils literal"><span class="pre">cobol.defs.DDE</span></tt></a>. This DDE will have a <a class="reference internal" href="#cobol.defs.Usage" title="cobol.defs.Usage"><tt class="xref py py-class docutils literal"><span class="pre">Usage</span></tt></a> object that shows
how to create the underlying <tt class="docutils literal"><span class="pre">Cell</span></tt> instance from the raw data
in the <a class="reference internal" href="cobol_init.html#cobol.COBOL_File" title="cobol.COBOL_File"><tt class="xref py py-class docutils literal"><span class="pre">cobol.COBOL_File</span></tt></a> subclass of <tt class="docutils literal"><span class="pre">Workbook</span></tt>.</p>
<p>For numeric types, this may mean a fallback from creating a <a class="reference internal" href="#cobol.defs.NumberCell" title="cobol.defs.NumberCell"><tt class="xref py py-class docutils literal"><span class="pre">NumberCell</span></tt></a>
to creating a <a class="reference internal" href="#cobol.defs.ErrorCell" title="cobol.defs.ErrorCell"><tt class="xref py py-class docutils literal"><span class="pre">ErrorCell</span></tt></a>. If the number is invalid in some way, then
an error is required.</p>
<p>The superclass of <tt class="docutils literal"><span class="pre">Usage</span></tt> is abstract and doesn&#8217;t compute a proper size.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Usage</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Covert numeric data based on Usage clause.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">source</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_</span><span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final</span><span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numeric</span><span class="o">=</span> <span class="bp">None</span> <span class="c"># is the picture all digits?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signed</span><span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimal</span><span class="o">=</span> <span class="bp">None</span>
    <span class="k">def</span> <span class="nf">setTypeInfo</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">picture</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Details from parsing a PICTURE clause.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final</span><span class="o">=</span> <span class="n">picture</span><span class="o">.</span><span class="n">final</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numeric</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">picture</span><span class="o">.</span><span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">picture</span><span class="o">.</span><span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">picture</span><span class="o">.</span><span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">picture</span><span class="o">.</span><span class="n">precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signed</span> <span class="o">=</span> <span class="n">picture</span><span class="o">.</span><span class="n">signed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimal</span> <span class="o">=</span> <span class="n">picture</span><span class="o">.</span><span class="n">decimal</span>
    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.defs.Usage.create_func">
<tt class="descclassname">Usage.</tt><tt class="descname">create_func</tt><big>(</big><big>)</big><a class="headerlink" href="#cobol.defs.Usage.create_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a CELL object. Use the raw bytes to build an Cell described
by the given Attribute.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">create_func</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts bytes to a proper Cell object.</span>
<span class="sd">    NOTE: EBCDIC-&gt;ASCII conversion handled by the Workbook object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">TextCell</span><span class="p">(</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.defs.Usage.size">
<tt class="descclassname">Usage.</tt><tt class="descname">size</tt><big>(</big><em>picture</em><big>)</big><a class="headerlink" href="#cobol.defs.Usage.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The count is in bytes.  Not characters.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">size</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">picture</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Default for group-level items.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.UsageDisplay">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">UsageDisplay</tt><a class="headerlink" href="#cobol.defs.UsageDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Usage &#8220;DISPLAY&#8221; is the COBOL language default.  It&#8217;s also assumed for group-level items.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UsageDisplay</span><span class="p">(</span> <span class="n">Usage</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ordinary character data which is numeric.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">source</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">source</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">create_func</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">NumberDisplayCell</span><span class="p">(</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">error</span><span class="o">=</span> <span class="n">ErrorCell</span><span class="p">(</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">exception</span><span class="o">=</span><span class="n">e</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">error</span>
        <span class="k">return</span> <span class="n">stingray</span><span class="o">.</span><span class="n">cobol</span><span class="o">.</span><span class="n">TextCell</span><span class="p">(</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the actual size of this data, based on PICTURE and SIGN.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final</span><span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.UsageComp">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">UsageComp</tt><a class="headerlink" href="#cobol.defs.UsageComp" title="Permalink to this definition">¶</a></dt>
<dd><p>Usage &#8220;COMPUTATIONAL&#8221; is binary-encoded data.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UsageComp</span><span class="p">(</span> <span class="n">Usage</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Binary-encoded COMP data which is numeric.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">source</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">source</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">create_func</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NumberCompCell</span><span class="p">(</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">error</span><span class="o">=</span> <span class="n">ErrorCell</span><span class="p">(</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">exception</span><span class="o">=</span><span class="n">e</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">error</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;COMP is binary half word, whole word or double word.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">4</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">8</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.UsageComp3">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">UsageComp3</tt><a class="headerlink" href="#cobol.defs.UsageComp3" title="Permalink to this definition">¶</a></dt>
<dd><p>Usage &#8220;COMP-3&#8221; is packed-decimal encoded data.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UsageComp3</span><span class="p">(</span> <span class="n">Usage</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Binary-Decimal packed COMP-3 data which is numeric.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">source</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">source</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">create_func</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NumberComp3Cell</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">error</span><span class="o">=</span> <span class="n">ErrorCell</span><span class="p">(</span> <span class="n">raw</span><span class="p">,</span> <span class="n">workbook</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">exception</span><span class="o">=</span><span class="n">e</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">error</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;COMP-3 is packed decimal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="allocation-strategy-hierarchy">
<h3>10.2.3.5.2. Allocation Strategy Hierarchy<a class="headerlink" href="#allocation-strategy-hierarchy" title="Permalink to this headline">¶</a></h3>
<p>We actually have three kinds of allocation relationships among DDE items.</p>
<ul class="simple">
<li>Predecessor/Successor</li>
<li>Group/Elementary</li>
<li>Redefines</li>
</ul>
<p>[<em>Formerly, we had only two subclasses.</em>]</p>
<p>This leads to a <strong>Strategy</strong> class hierarchy to handle the various algorithmic
choices.</p>
<p>The Pred/Succ strategy computes the offset to a specific item based on the predecessor.
This is the default for non-head items in a group.</p>
<p>The Group/Elem strategy computes the offset based on the offset to the parent group.
This is the default for the head item in a group.</p>
<p>The Redefines strategy depends on another element: not it&#8217;s immediate predecessor.
This element will be assigned the same offset as the element on which it depends.</p>
<p>The <strong>Strategy</strong> design pattern allows an element to delegate the
<a class="reference internal" href="#cobol.defs.Redefines.offset" title="cobol.defs.Redefines.offset"><tt class="xref py py-meth docutils literal"><span class="pre">Redefines.offset()</span></tt></a>,
and <a class="reference internal" href="#cobol.defs.Redefines.totalSize" title="cobol.defs.Redefines.totalSize"><tt class="xref py py-meth docutils literal"><span class="pre">Redefines.totalSize()</span></tt></a> methods.</p>
<div class="highlight-none"><div class="highlight"><pre>http://yuml.me/diagram/scruffy;/class/
#cobol_loader_redefines,
[RecordFactory]&lt;&gt;-[DDE],
[DDE]&lt;&gt;-[DDE],
[DDE]-[Allocation],
[Allocation]^[Redefines],
[Allocation]^[Pred-Succ],
[Allocation]^[Group-Elem]
</pre></div>
</div>
<img alt="_images/cobol_redefines.png" src="_images/cobol_redefines.png" />
<dl class="class">
<dt id="cobol.defs.Allocation">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">Allocation</tt><a class="headerlink" href="#cobol.defs.Allocation" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#cobol.defs.Allocation" title="cobol.defs.Allocation"><tt class="xref py py-class docutils literal"><span class="pre">Allocation</span></tt></a> superclass defines an abstract base
class for the various allocation strategies.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Allocation</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="o">=</span> <span class="bp">None</span>
    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aDDE</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Associate back to the owning DDE.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">aDDE</span><span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.Redefines">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">Redefines</tt><a class="headerlink" href="#cobol.defs.Redefines" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#cobol.defs.Redefines" title="cobol.defs.Redefines"><tt class="xref py py-class docutils literal"><span class="pre">Redefines</span></tt></a> subclass depends on another element. It uses
the referenced name to look up the offset and total size information.</p>
<p>For this to work, the name must be resolved via the <a class="reference internal" href="#cobol.defs.Redefines.resolve" title="cobol.defs.Redefines.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">Redefines.resolve()</span></tt></a> method.
The <a class="reference internal" href="#cobol.defs.resolver" title="cobol.defs.resolver"><tt class="xref py py-func docutils literal"><span class="pre">resolver()</span></tt></a> function applies the <a class="reference internal" href="#cobol.defs.Redefines.resolve" title="cobol.defs.Redefines.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">Redefines.resolve()</span></tt></a> method throughout the structure.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Redefines</span><span class="p">(</span><span class="n">Allocation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lookup size and offset from another field we refer to.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">refers_to</span><span class="o">=</span><span class="bp">None</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refers_to</span><span class="o">=</span> <span class="n">refers_to</span> <span class="c"># Used for unit testing</span>
    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;REDEFINES {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">refers_to</span><span class="o">.</span><span class="n">name</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.defs.Redefines.resolve">
<tt class="descclassname">Redefines.</tt><tt class="descname">resolve</tt><big>(</big><em>aDDE</em><big>)</big><a class="headerlink" href="#cobol.defs.Redefines.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve a DDE name. See our <tt class="docutils literal"><span class="pre">self.refers_to</span></tt> to refer to a DDE within
the given structure.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aDDE</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search the structure for the referenced name.</span>
<span class="sd">    Must be done before sizing can be done.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span> <span class="n">aDDE</span> <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">refers_to</span><span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">top</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.defs.Redefines.offset">
<tt class="descclassname">Redefines.</tt><tt class="descname">offset</tt><big>(</big><em>offset</em><big>)</big><a class="headerlink" href="#cobol.defs.Redefines.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>For a redefines, this uses the resolved <tt class="docutils literal"><span class="pre">refers_to</span></tt> name and fetches
the offset.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">offset</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">offset</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;:param offset: computed offset for this relative position.</span>
<span class="sd">    :return: named DDE element offset instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refers_to</span><span class="o">.</span><span class="n">offset</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.defs.Redefines.totalSize">
<tt class="descclassname">Redefines.</tt><tt class="descname">totalSize</tt><big>(</big><big>)</big><a class="headerlink" href="#cobol.defs.Redefines.totalSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total size.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">totalSize</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;:return: total size of this DDE include all children and occurs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;totalSize method is deprecated&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span> <span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">01</span></tt> level items may have a REDEFINES.
However, this can never meaningfully redefine anything.
All  <tt class="docutils literal"><span class="pre">01</span></tt> level definitions start at an offset of 0 by definition.
A copybook may include multiple <tt class="docutils literal"><span class="pre">01</span></tt> levels with REDEFINES clauses;
an 01-level REDEFINES is irrelevant with respect to offset and size calculations.</p>
<dl class="class">
<dt id="cobol.defs.Successor">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">Successor</tt><a class="headerlink" href="#cobol.defs.Successor" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#cobol.defs.Successor" title="cobol.defs.Successor"><tt class="xref py py-class docutils literal"><span class="pre">Successor</span></tt></a>
subclass does not depend on a named element, it depends on the immediate
predecessor. It uses that contextual offset and size information provided by
the <a class="reference internal" href="#cobol.defs.setSizeAndOffset" title="cobol.defs.setSizeAndOffset"><tt class="xref py py-func docutils literal"><span class="pre">setSizeAndOffset()</span></tt></a> function.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Successor</span><span class="p">(</span><span class="n">Allocation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;More typical case is that the DDE follows it&#39;s predecessor.</span>
<span class="sd">    It&#39;s not first in a group, nor is it a redefines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pred</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refers_to</span><span class="o">=</span> <span class="n">pred</span>
    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&quot;</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.defs.Successor.offset">
<tt class="descclassname">Successor.</tt><tt class="descname">offset</tt><big>(</big><em>offset</em><big>)</big><a class="headerlink" href="#cobol.defs.Successor.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>For a successor, we use the predecessor in the <tt class="docutils literal"><span class="pre">refers_to</span></tt> field
to track down the offset of the predecessor.</p>
<p>This field&#8217;s offset is predecessor offset + predecessor total size.</p>
<p>The predecessor may have to do some thinking to get its total size or
offset because of an Occurs Depending On situation.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">offset</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">offset</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;:param offset: computed offset to this point.</span>
<span class="sd">    :return: computed offset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">offset</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.defs.Successor.totalSize">
<tt class="descclassname">Successor.</tt><tt class="descname">totalSize</tt><big>(</big><big>)</big><a class="headerlink" href="#cobol.defs.Successor.totalSize" title="Permalink to this definition">¶</a></dt>
<dd><p>The total size of a field with occurs depending on requires a record with live data.
Otherwise, the total size is trivially computed from the DDE definition.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">totalSize</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;:return: total size of this DDE include all children and occurs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;totalSize method is deprecated&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span> <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="p">()</span><span class="o">.</span><span class="n">totalSize</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.Group">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">Group</tt><a class="headerlink" href="#cobol.defs.Group" title="Permalink to this definition">¶</a></dt>
<dd><p>This subclass does not depend on a named element, it depends on the immediate
parent group. It uses that contextual offset and size information provided by
the <a class="reference internal" href="#cobol.defs.setSizeAndOffset" title="cobol.defs.setSizeAndOffset"><tt class="xref py py-func docutils literal"><span class="pre">setSizeAndOffset()</span></tt></a> function.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">Allocation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;More typical case is that the DDE is first under a parent.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&quot;</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.defs.Group.offset">
<tt class="descclassname">Group.</tt><tt class="descname">offset</tt><big>(</big><em>offset</em><big>)</big><a class="headerlink" href="#cobol.defs.Group.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>For the first item in a group, we use the group parent in the <tt class="docutils literal"><span class="pre">dde</span></tt> field
to track down the offset of the group we&#8217;re a member of.</p>
<p>This field&#8217;s offset is the group offset, since this field is first in the group.</p>
<p>The group may have to do some recursive processing to get its predecessor&#8217;s total size or
offset because of an Occurs Depending On situation.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">offset</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">offset</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;:param offset: computed offset</span>
<span class="sd">    :return: computed offset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">offset</span>
</pre></div>
</div>
<dl class="method">
<dt id="cobol.defs.Group.totalSize">
<tt class="descclassname">Group.</tt><tt class="descname">totalSize</tt><big>(</big><big>)</big><a class="headerlink" href="#cobol.defs.Group.totalSize" title="Permalink to this definition">¶</a></dt>
<dd><p>This is essentially the same as the successor &#8211; it&#8217;s merely an item within a DDE,
we just track the first items separately with this subclass so that they
can refer to the parent to walk up the tree.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">totalSize</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;:return: total size of this DDE include all children and occurs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;totalSize method is deprecated&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span> <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="p">()</span><span class="o">.</span><span class="n">totalSize</span>
</pre></div>
</div>
</div>
<div class="section" id="occurs-strategy-hierarchy">
<h3>10.2.3.5.3. Occurs Strategy Hierarchy<a class="headerlink" href="#occurs-strategy-hierarchy" title="Permalink to this headline">¶</a></h3>
<p>There are three species of Occurs clauses.</p>
<ul class="simple">
<li>Format 1. Fixed OCCURS with a number.</li>
<li>Format 2. Variable OCCURS DEPENDING ON with a number and a name.
The <a class="reference internal" href="#cobol.defs.resolver" title="cobol.defs.resolver"><tt class="xref py py-func docutils literal"><span class="pre">resolver()</span></tt></a> function sorts out the reference.
Similar to the way REDEFINES is handled.</li>
<li>Format 0. No Occurs, effectively OCCURS == 1 with no dimensionality issues.</li>
</ul>
<p>This means that the <tt class="docutils literal"><span class="pre">number</span></tt> attribute must be derived EITHER from the definition
or a data record. For ODO, we need to bind the definition to a record.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>Dependencies between DDE and Attribute</p>
<p>An OCCURS is a feature of the DDE.
Data access, however, requires the <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute</span></tt></a>.
There&#8217;s no <strong>direct</strong> linkage from <a class="reference internal" href="#cobol.defs.DDE" title="cobol.defs.DDE"><tt class="xref py py-class docutils literal"><span class="pre">cobol.defs.DDE</span></tt></a> to <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute</span></tt></a>.
There is linkage from <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute</span></tt></a> to <a class="reference internal" href="#cobol.defs.DDE" title="cobol.defs.DDE"><tt class="xref py py-class docutils literal"><span class="pre">cobol.defs.DDE</span></tt></a>.</p>
<p>It seems best to have Attribute independent of any particular
source. A schema may not necessarily come from COBOL.</p>
<p>However.</p>
<p class="last">To facilitate a DDE-oriented dump of raw data or specific fields of a COBOL
file, we include a <tt class="xref py py-mod docutils literal"><span class="pre">weakref</span></tt> from the <tt class="docutils literal"><span class="pre">DDE</span></tt> to the <tt class="docutils literal"><span class="pre">Attribute</span></tt> created
from that DDE.</p>
</div>
<p>The overall top-most parent DDE associated with this object is <tt class="docutils literal"><span class="pre">self.dde().top()</span></tt>.</p>
<dl class="class">
<dt id="cobol.defs.Occurs">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">Occurs</tt><a class="headerlink" href="#cobol.defs.Occurs" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract superclass for an Occurs clause.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Occurs</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;No OCCURS clause present. Data from a row is irrelevant.&quot;&quot;&quot;</span>
    <span class="n">default</span><span class="o">=</span> <span class="bp">True</span>
    <span class="n">static</span><span class="o">=</span> <span class="bp">True</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aDDE</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dde</span><span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">aDDE</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">number</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aRow</span> <span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.OccursFixed">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">OccursFixed</tt><a class="headerlink" href="#cobol.defs.OccursFixed" title="Permalink to this definition">¶</a></dt>
<dd><p>Occurs clause with a simple fixed number of occurrences.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">OccursFixed</span><span class="p">(</span> <span class="n">Occurs</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;OCCURS n TIMES. Data from a row is irrelevant.&quot;&quot;&quot;</span>
    <span class="n">default</span><span class="o">=</span> <span class="bp">False</span>
    <span class="n">static</span><span class="o">=</span> <span class="bp">True</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">number</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;OCCURS {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aDDE</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">aDDE</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">number</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aRow</span> <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.OccursDependingOn">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">OccursDependingOn</tt><a class="headerlink" href="#cobol.defs.OccursDependingOn" title="Permalink to this definition">¶</a></dt>
<dd><p>Occurs clause with a DEPENDING ON option.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">OccursDependingOn</span><span class="p">(</span> <span class="n">Occurs</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;OCCURS TO n TIMES DEPENDING ON name. Data from a row is required.&quot;&quot;&quot;</span>
    <span class="n">default</span><span class="o">=</span> <span class="bp">False</span>
    <span class="n">static</span><span class="o">=</span> <span class="bp">False</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">limit</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refers_to</span><span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">=</span> <span class="bp">None</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;OCCURS TO {0} DEPENDING ON {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aDDE</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">aDDE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refers_to</span><span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">top</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">number</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aRow</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;aRow.cell( schema.get(self.name) ) should have a numeric value.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">schema_dict</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">aRow</span><span class="o">.</span><span class="n">sheet</span><span class="o">.</span><span class="n">schema</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">=</span> <span class="n">schema_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="c">## logger.debug( &quot;Getting {0} from {1}&quot;.format(self.attr,aRow) )</span>
        <span class="n">value</span><span class="o">=</span> <span class="n">aRow</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="p">)</span><span class="o">.</span><span class="n">to_int</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">value</span>
</pre></div>
</div>
<dl class="class">
<dt id="cobol.defs.OccursDependingOnLimit">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">OccursDependingOnLimit</tt><a class="headerlink" href="#cobol.defs.OccursDependingOnLimit" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an extension to OccursDependingOn. It limits the ODO clause to the defined
upper bound.</p>
<p>If we have <tt class="docutils literal"><span class="pre">05</span> <span class="pre">SOMETHING</span> <span class="pre">OCCURS</span> <span class="pre">1</span> <span class="pre">TO</span> <span class="pre">5</span> <span class="pre">TIMES</span> <span class="pre">DEPENDING</span> <span class="pre">ON</span> <span class="pre">X</span></tt> and
the value of <tt class="docutils literal"><span class="pre">X</span></tt> is greater than 5, the maximum defined value, 5, is used.</p>
<p>This entirely hypothetical as a possible fix to a problem. It&#8217;s probably a
Very Bad Idea, and should be removed.</p>
<p>See <a class="reference external" href="http://pic.dhe.ibm.com/infocenter/ratdevz/v8r0/index.jsp?topic=%2Fcom.ibm.ent.cbl.zos.doc%2Ftopics%2FMG%2Figymch1027.htm">http://pic.dhe.ibm.com/infocenter/ratdevz/v8r0/index.jsp?topic=%2Fcom.ibm.ent.cbl.zos.doc%2Ftopics%2FMG%2Figymch1027.htm</a></p>
<blockquote>
<div><p>&#8220;When the maximum length is used, it is not necessary to initialize the ODO object before the table receives data.&#8221;</p>
<p>&#8220;When TABLE-GROUP-1 is a receiving item, Enterprise COBOL moves the maximum number of character positions for it (450 bytes for TABLE-1 plus two bytes for ODO-KEY-1). Therefore, you need not initialize the length of TABLE-1 before moving the SEND-ITEM-1 data into the table.&#8221;</p>
</div></blockquote>
<p>Based on this (and bad data seen in the wild) we deduce that this upper limit
clamping <strong>may</strong> be a language  feature.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">OccursDependingOnLimit</span><span class="p">(</span> <span class="n">OccursDependingOn</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;OCCURS TO n TIMES DEPENDING ON name. Data is required.</span>
<span class="sd">    This will clamp the result at the given upper limit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">number</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aRow</span> <span class="p">):</span>
        <span class="n">value</span><span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">number</span><span class="p">(</span> <span class="n">aRow</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span>
        <span class="k">return</span> <span class="n">value</span>
</pre></div>
</div>
</div>
<div class="section" id="dde-class">
<h3>10.2.3.5.4. DDE Class<a class="headerlink" href="#dde-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cobol.defs.DDE">
<em class="property">class </em><tt class="descclassname">cobol.defs.</tt><tt class="descname">DDE</tt><a class="headerlink" href="#cobol.defs.DDE" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#cobol.defs.DDE" title="cobol.defs.DDE"><tt class="xref py py-class docutils literal"><span class="pre">DDE</span></tt></a> class itself defines a single element (group or elementary) of a
record.  There are several broad areas of functionality for a DDE:
(1) construction, (2) reporting and decoration, (3) processing record data.</p>
<p>The class definition includes the attributes determined at
parse time, attributes added during decoration time and
attributes used during decoration processing.</p>
<p>As noted above, Group-level vs. Elementary-level <em>could</em> be separate subclasses of DDE.
They aren&#8217;t right now, since group-level items can be used in an application program
like elementary items.</p>
<p>A group-level item contains subsidiary DDE&#8217;s and has no PICTURE clause.
An elementary-level DDE is defined by having a PICTURE clause.</p>
<p>All group-level DDE&#8217;s are effectively string-type data.
An elementary-level DDE with a numeric PICTURE is numeric-type data.  It can
be usage display or usage computational.  An elementary-level DDE with a string PICTURE is string-type data.</p>
<p>Occurs and Redefines can occur at any level.</p>
<p>Each entry is defined by the following attributes:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Level:</th><td class="field-body">COBOL level number 01 to 49, 66 or 88.</td>
</tr>
<tr class="field-even field"><th class="field-name">MyName:</th><td class="field-body">COBOL variable name</td>
</tr>
<tr class="field-odd field"><th class="field-name">Occurs:</th><td class="field-body">An instance of <a class="reference internal" href="#cobol.defs.Occurs" title="cobol.defs.Occurs"><tt class="xref py py-class docutils literal"><span class="pre">Occurs</span></tt></a>.
the number of occurrences. The default is 1, which we call &#8220;format 0&#8221;.
There are two defined formats: format 1 has a fixed number of occurrences;
format 2 is the Occurs Depending On with a variable number of occurrences.</td>
</tr>
<tr class="field-even field"><th class="field-name">Picture:</th><td class="field-body">the exploded picture clause, with ()&#8217;s expanded</td>
</tr>
<tr class="field-odd field"><th class="field-name">InitValue:</th><td class="field-body">any initial value provided</td>
</tr>
<tr class="field-even field"><th class="field-name">Allocation:</th><td class="field-body">an instance of <a class="reference internal" href="#cobol.defs.Allocation" title="cobol.defs.Allocation"><tt class="xref py py-class docutils literal"><span class="pre">Allocation</span></tt></a> used to compute the offset and total size.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body">an instance of <a class="reference internal" href="#cobol.defs.Usage" title="cobol.defs.Usage"><tt class="xref py py-class docutils literal"><span class="pre">Usage</span></tt></a> to delegate data conversion properly.
The actual conversion is handled by the workbook.</td>
</tr>
<tr class="field-even field"><th class="field-name">Contains:</th><td class="field-body">the list of contained fields within a group</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parent:</th><td class="field-body">A weakref to the immediate parent DDE</td>
</tr>
<tr class="field-even field"><th class="field-name">Top:</th><td class="field-body">A weakref to the overall record definition DDE.</td>
</tr>
</tbody>
</table>
<p>The following decorations are applied by functions that traverse the DDE structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">SizeScalePrecision:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><tt class="docutils literal"><span class="pre">Picture</span></tt> namedtuple with details derived from parsing the PICTURE clause</td>
</tr>
<tr class="field-even field"><th class="field-name">Size:</th><td class="field-body">the size of an individual occurrence</td>
</tr>
</tbody>
</table>
<p>The following features may have to be computed lazily if there&#8217;s an Occurs
Depending On. Otherwise they can be computed eagerly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Variably_located:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Variably Located if any this element or any child has Occurs Depending On.
Otherwise (no ODO) the DDE is Statically Located.
Actually, only element <strong>after</strong> the ODO element are variably located. But it&#8217;s simpler
to treat the whole record as variable.</td>
</tr>
<tr class="field-even field"><th class="field-name">Offset:</th><td class="field-body">offset to this field from start of record.</td>
</tr>
<tr class="field-odd field"><th class="field-name">TotalSize:</th><td class="field-body">overall size of this item, including all occurrences.</td>
</tr>
</tbody>
</table>
<p>Additionally, this item &#8211; in a way &#8211; breaks the dependencies between
a <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute</span></tt></a> and a DDE. It&#8217;s appropriate for an Attribute
to depend on a DDE, but the reverse isn&#8217;t proper. However, we DDE
referring to an attribute anyway.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attribute:</th><td class="field-body">weakref to the <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute</span></tt></a> built from this DDE.</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">DDE</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A Data Description Entry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">usage</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">occurs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">redefines</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="n">initValue</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pic</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sizeScalePrecision</span><span class="o">=</span><span class="bp">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build this with the results of parsing the various clauses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="o">=</span> <span class="n">level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occurs</span><span class="o">=</span> <span class="n">occurs</span> <span class="k">if</span> <span class="n">occurs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">Occurs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">picture</span><span class="o">=</span> <span class="n">pic</span> <span class="c"># source, prior to parsing, below.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocation</span><span class="o">=</span> <span class="n">redefines</span> <span class="c"># Redefines or Successor or Group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usage</span><span class="o">=</span> <span class="n">usage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initValue</span><span class="o">=</span> <span class="n">initValue</span>

        <span class="c"># Parsed picture information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sizeScalePrecision</span><span class="o">=</span> <span class="n">sizeScalePrecision</span>

        <span class="c"># Relationships</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">=</span> <span class="bp">None</span> <span class="c"># must be a weakref.ref()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">=</span> <span class="bp">None</span> <span class="c"># must be a weakref.ref()</span>

        <span class="c"># Derived property from the picture clause</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

        <span class="c"># Because of ODO, these cannot always be computed statically.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="o">=</span> <span class="mi">0</span> <span class="c"># self.allocation.refers_to.offset + self.allocation.refers_to.total_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">totalSize</span><span class="o">=</span> <span class="mi">0</span> <span class="c"># self.size * self.occurs.number(aRow)</span>

        <span class="c"># Derived attribute created from this DDE.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span><span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;{:s} {:s} {:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="n">oc</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occurs</span><span class="p">)</span>
        <span class="n">pc</span><span class="o">=</span> <span class="s">&quot; PIC {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picture</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">picture</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>
        <span class="n">uc</span><span class="o">=</span> <span class="s">&quot; USAGE {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span><span class="o">.</span><span class="n">source</span><span class="p">()</span> <span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span><span class="o">.</span><span class="n">source</span><span class="p">()</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>
        <span class="n">rc</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocation</span><span class="o">.</span><span class="n">source</span><span class="p">()</span>
        <span class="k">return</span> <span class="s">&quot;{:&lt;2s} {:&lt;20s}{:s}{:s}{:s}{:s}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">oc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">uc</span> <span class="p">)</span>
</pre></div>
</div>
<p>Construction occurs in three general steps:</p>
<ol class="arabic simple">
<li>the DDE is created,</li>
<li>source attributes are set,</li>
<li>the DDE is decorated with size, offset and other details.</li>
<li>the DDE is transformed into a <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute</span></tt></a>.</li>
</ol>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">addChild</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aDDE</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add a substructure to this DDE.</span>

<span class="sd">    This is used by RecordFactory to assemble the DDE.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">allocation</span><span class="p">:</span>
        <span class="c"># has a redefines, leave it alone</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">aDDE</span><span class="o">.</span><span class="n">allocation</span><span class="o">=</span> <span class="n">Successor</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aDDE</span><span class="o">.</span><span class="n">allocation</span><span class="o">=</span> <span class="n">Group</span><span class="p">()</span>
    <span class="n">aDDE</span><span class="o">.</span><span class="n">top</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="c"># Already a weakref</span>
    <span class="n">aDDE</span><span class="o">.</span><span class="n">parent</span><span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">aDDE</span><span class="o">.</span><span class="n">indent</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="o">+</span><span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">aDDE</span> <span class="p">)</span>
</pre></div>
</div>
<p>This iterator does a pre-order depth-first
traversal of the subtree. This provides a single, flat list of all elements.</p>
<dl class="class">
<dt id="cobol.defs.DDE.__iter__">
<em class="property">class </em><tt class="descclassname">DDE.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#cobol.defs.DDE.__iter__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="k">yield</span> <span class="bp">self</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dde</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">dde</span>
</pre></div>
</div>
<p>The process of scanning a record involves methods to locate a specific field,
set the occurrence index of a field, and pick bytes of a record input buffer.</p>
<p>We work with <tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt>-separated path names through the hierarchy. This doesn&#8217;t work
well in the presence of OCCURS clauses and indexes. For that, we need more
complex navigation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">pathTo</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the complete &quot;.&quot;-delimited path to this DDE.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">pathTo</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="k">def</span> <span class="nf">getPath</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">path</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a &quot;.&quot;-punctuated Path, locate the field.</span>
<span class="sd">    COBOL uses &quot;of&quot; for this.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">context</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="c"># In case we&#39;re not the top.</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">):</span>
        <span class="n">context</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="n">name</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">context</span>

<span class="k">def</span> <span class="nf">get</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the named field, and return the relevant substructure.</span>
<span class="sd">    :param: name of the DDE element</span>
<span class="sd">    :return: DDE Object</span>
<span class="sd">    :raises: AttributeError if field not found</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">found</span><span class="o">=</span> <span class="n">search</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">(),</span> <span class="n">name</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">found</span>
    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span> <span class="s">&quot;Field {:s} unknown in this record&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Work with Occurs Depending On. The <tt class="xref py py-meth docutils literal"><span class="pre">variably_located()</span></tt> question
may only apply to top-level (01, parent=None) DDE&#8217;s.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@property</span>
<span class="k">def</span> <span class="nf">variably_located</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occurs</span><span class="o">.</span><span class="n">static</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">variably_located</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="p">)</span>
    <span class="k">return</span> <span class="bp">True</span> <span class="c"># Not static</span>

<span class="k">def</span> <span class="nf">setSizeAndOffset</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aRow</span> <span class="p">):</span>
    <span class="n">setSizeAndOffset</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aRow</span> <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dde-preparation-processing">
<h2>10.2.3.6. DDE Preparation Processing<a class="headerlink" href="#dde-preparation-processing" title="Permalink to this headline">¶</a></h2>
<p>There are a number of classes (and functions) to support
parsing. We need to transform the DDE&#8217;s to
a <a class="reference internal" href="schema.html#schema.Schema" title="schema.Schema"><tt class="xref py py-class docutils literal"><span class="pre">schema.Schema</span></tt></a> which is a flattened
list of <a class="reference internal" href="schema.html#schema.Attribute" title="schema.Attribute"><tt class="xref py py-class docutils literal"><span class="pre">schema.Attribute</span></tt></a> objects for each element in the DDE.</p>
<p>There are a number of processing steps which are applied to the overall DDE.
These functions depend on the DDE&#8217;s ability to do it&#8217;s own recursive pre-order
traversal as an iterator.</p>
<ul class="simple">
<li><a class="reference internal" href="#cobol.defs.source" title="cobol.defs.source"><tt class="xref py py-func docutils literal"><span class="pre">source()</span></tt></a>. Dumps canonical source.</li>
<li><a class="reference internal" href="#cobol.defs.report" title="cobol.defs.report"><tt class="xref py py-func docutils literal"><span class="pre">report()</span></tt></a>. Reports on the compiled results.</li>
<li><a class="reference internal" href="#cobol.defs.search" title="cobol.defs.search"><tt class="xref py py-func docutils literal"><span class="pre">search()</span></tt></a>. Searches through the hierarchy.</li>
<li><a class="reference internal" href="#cobol.defs.resolver" title="cobol.defs.resolver"><tt class="xref py py-func docutils literal"><span class="pre">resolver()</span></tt></a>. Resolves REDEFINES and DEPENDING ON.</li>
<li><a class="reference internal" href="#cobol.defs.setDimensionality" title="cobol.defs.setDimensionality"><tt class="xref py py-func docutils literal"><span class="pre">setDimensionality()</span></tt></a>. Propagates dimensionality down from group
to elementary items.</li>
</ul>
<p>Additionally, we want to prepare for size and offset calculation.
Sometimes, there are no ODO&#8217;s and we can compute these statically.
Other times, there&#8217;s an ODO and we can&#8217;t compute size or offset without
data.</p>
<dl class="function">
<dt id="cobol.defs.report">
<tt class="descclassname">cobol.defs.</tt><tt class="descname">report</tt><big>(</big><em>top</em><big>)</big><a class="headerlink" href="#cobol.defs.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the structure of this DDE in COBOL-like notation enriched with
offsets and sizes.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">report</span><span class="p">(</span> <span class="n">top</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Report on copybook structure.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">aDDE</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">variably_located</span><span class="p">:</span>
            <span class="k">pass</span> <span class="c"># Nothing special (yet)</span>
        <span class="k">if</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">sizeScalePrecision</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">sizeScalePrecision</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
            <span class="n">final</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">signed</span><span class="p">,</span> <span class="n">decimal</span> <span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">sizeScalePrecision</span>
            <span class="n">nSpec</span><span class="o">=</span> <span class="s">&#39;{:d}.{:d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">length</span><span class="p">,</span> <span class="n">precision</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nSpec</span><span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span> <span class="s">&quot;{:&lt;65s} {:3d} {:3d} {:5s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aDDE</span><span class="o">.</span><span class="n">indent</span><span class="o">*</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">aDDE</span><span class="p">),</span>
            <span class="n">aDDE</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">nSpec</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="function">
<dt id="cobol.defs.source">
<tt class="descclassname">cobol.defs.</tt><tt class="descname">source</tt><big>(</big><em>top</em><big>)</big><a class="headerlink" href="#cobol.defs.source" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a version of the source.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">source</span><span class="p">(</span> <span class="n">top</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Display a canonical version of the source from copybook parsing.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">aDDE</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">indent</span><span class="o">*</span><span class="s">&#39;  &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">aDDE</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="function">
<dt id="cobol.defs.search">
<tt class="descclassname">cobol.defs.</tt><tt class="descname">search</tt><big>(</big><em>top</em>, <em>aName</em><big>)</big><a class="headerlink" href="#cobol.defs.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the structure for a given name.
This returns the found value or <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">search</span><span class="p">(</span> <span class="n">top</span><span class="p">,</span> <span class="n">aName</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search down through the copybook structure.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">aDDE</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">aName</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">aDDE</span>
</pre></div>
</div>
<dl class="function">
<dt id="cobol.defs.resolver">
<tt class="descclassname">cobol.defs.</tt><tt class="descname">resolver</tt><big>(</big><em>top</em><big>)</big><a class="headerlink" href="#cobol.defs.resolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply <tt class="xref py py-meth docutils literal"><span class="pre">Allocation.resolve()</span></tt> throughout the structure.
For each <tt class="docutils literal"><span class="pre">REDEFINES</span></tt> or <tt class="docutils literal"><span class="pre">OCCURS</span> <span class="pre">DEPENDING</span> <span class="pre">ON</span></tt> clause, locate the DDE to which
it refers, saving a repeated searches.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">resolver</span><span class="p">(</span> <span class="n">top</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;For each DDE.allocation which is based on REDEFINES, locate the referenced</span>
<span class="sd">    name.  For each DDE.occurs which has OCCURS DEPENDING ON, locate the</span>
<span class="sd">    referenced name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">aDDE</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
        <span class="n">aDDE</span><span class="o">.</span><span class="n">allocation</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span> <span class="n">aDDE</span> <span class="p">)</span>
        <span class="n">aDDE</span><span class="o">.</span><span class="n">occurs</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span> <span class="n">aDDE</span> <span class="p">)</span>
</pre></div>
</div>
<p>For allocation, we have three relationships:
Successor, Group, and Redefines.
The first two don&#8217;t involve names. Only Redefines involves a name that we want
to resolve before proceeding.</p>
<p>We <em>could</em> rely on memoization and do name resolution lazily as needed.</p>
<p>For occurs, we also have three versions:
Default (effectively 1), Fixed, and Depends On.
The first two don&#8217;t involve names. Only Depends On involves a name that we want
to resolve before proceeding.</p>
<dl class="function">
<dt id="cobol.defs.setDimensionality">
<tt class="descclassname">cobol.defs.</tt><tt class="descname">setDimensionality</tt><big>(</big><em>top</em><big>)</big><a class="headerlink" href="#cobol.defs.setDimensionality" title="Permalink to this definition">¶</a></dt>
<dd><p>Set Dimensionality for each DDE.
This will be the sequence of the non-default <tt class="docutils literal"><span class="pre">OCCURS</span></tt> clauses that apply to each item.
This is the item&#8217;s, plus any belonging to the parents of the item.</p>
<p>The order is from top down to the elementary item.</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">setDimensionality</span><span class="p">(</span> <span class="n">top</span> <span class="p">):</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span> <span class="n">aDDE</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:returns: A tuple of parental DDE&#39;s with non-1 occurs clauses.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">occurs</span><span class="o">.</span><span class="n">default</span><span class="p">:</span>
            <span class="n">this_level</span><span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this_level</span><span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span> <span class="p">(</span><span class="n">aDDE</span><span class="p">,)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dimensions</span><span class="p">(</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="p">)</span> <span class="o">+</span> <span class="n">this_level</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Reached the top!</span>
            <span class="k">return</span> <span class="n">this_level</span>
    <span class="k">for</span> <span class="n">aDDE</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
        <span class="n">aDDE</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">(</span> <span class="n">aDDE</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="set-size-and-offset">
<h2>10.2.3.7. Set Size and Offset<a class="headerlink" href="#set-size-and-offset" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, we can calculate field sizes and offsets statically.
If <tt class="docutils literal"><span class="pre">not</span> <span class="pre">top.variably_located</span></tt> then the structure is entirely static.
This function walks the structure, setting total size and offset.</p>
<p>Other times the locations are variable. If <tt class="docutils literal"><span class="pre">top.variably_located</span></tt> then
the structure has at least one ODO.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p>refactor setSizeAndOffset()</p>
<p class="last">Refactor setSizeAndOffset() into the <a class="reference internal" href="#cobol.defs.Allocation" title="cobol.defs.Allocation"><tt class="xref py py-class docutils literal"><span class="pre">Allocation</span></tt></a> class methods
to remove isinstance() nonsense.</p>
</div>
<dl class="function">
<dt id="cobol.defs.setSizeAndOffset">
<tt class="descclassname">cobol.defs.</tt><tt class="descname">setSizeAndOffset</tt><big>(</big><em>aDDE</em>, <em>aRow=None</em>, <em>base=0</em><big>)</big><a class="headerlink" href="#cobol.defs.setSizeAndOffset" title="Permalink to this definition">¶</a></dt>
<dd><p>This can be used with or without a row. The common case of all statically
located items does not require a row.
It must be used with a row for the case of OCCURS Depending On.</p>
</dd></dl>

<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p>Fix performance.</p>
<p class="last">This is called once per row: it needs to be simpler and
faster. Some refactoring can eliminate the if statements.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">setSizeAndOffset</span><span class="p">(</span> <span class="n">aDDE</span><span class="p">,</span> <span class="n">aRow</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a top-level DDE, a Row of data (or None),</span>
<span class="sd">    assign offset, size, totalSize.</span>
<span class="sd">    Also, the case of an 88-level item, copy the parent USAGE to the child.</span>

<span class="sd">    size is the instance size. For non-group items, it comes from the</span>
<span class="sd">    PIC and OCCURS. For group items it&#39;s the sum of the children&#39;s sizes.</span>

<span class="sd">    totalSize = size * occurs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Pre-order: handle this item first.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aDDE</span><span class="o">.</span><span class="n">allocation</span><span class="p">,</span> <span class="n">Redefines</span><span class="p">):</span>
        <span class="c"># REDEFINES simply copies details from the other item.</span>
        <span class="c"># TODO: Push into Redefines</span>
        <span class="c"># base= aDDE.offset= allocation.offset( base )</span>
        <span class="n">base</span><span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">offset</span><span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">allocation</span><span class="o">.</span><span class="n">refers_to</span><span class="o">.</span><span class="n">offset</span>
        <span class="n">aDDE</span><span class="o">.</span><span class="n">totalSize</span><span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">allocation</span><span class="o">.</span><span class="n">refers_to</span><span class="o">.</span><span class="n">totalSize</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># TODO: Push into Allocation as the generic rule.</span>
        <span class="c"># base= aDDE.offset= allocation.offset( base )</span>
        <span class="n">aDDE</span><span class="o">.</span><span class="n">offset</span><span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">allocation</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">aDDE</span><span class="o">.</span><span class="n">totalSize</span><span class="o">=</span> <span class="mi">0</span>
    <span class="c"># Initialize the size -- it may get updated below for group-level items.</span>
    <span class="n">aDDE</span><span class="o">.</span><span class="n">size</span><span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">usage</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="c">## logger.debug( &quot;{0} Enter {1} offset={2}&quot;.format(&quot;&gt;&quot;*aDDE.indent, aDDE, aDDE.offset) )</span>

    <span class="c"># For non-picture group-level, handle all of the children.</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="n">setSizeAndOffset</span><span class="p">(</span> <span class="n">child</span><span class="p">,</span> <span class="n">aRow</span><span class="p">,</span> <span class="n">base</span> <span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">totalSize</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">allocation</span><span class="p">,</span> <span class="n">Redefines</span><span class="p">):</span>
            <span class="c"># TODO: Push into Redefines: does nothing.</span>
            <span class="c"># aDDE.size+= allocation.size()</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># TODO: Push into Allocation as the generic rule.</span>
            <span class="c"># aDDE.size+= allocation.size()</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">level</span> <span class="o">==</span> <span class="s">&#39;88&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aDDE</span><span class="o">.</span><span class="n">size</span><span class="o">+=</span> <span class="n">child</span><span class="o">.</span><span class="n">totalSize</span>

    <span class="c"># Collect final results from handling the children.</span>
    <span class="n">aDDE</span><span class="o">.</span><span class="n">totalSize</span> <span class="o">=</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">aDDE</span><span class="o">.</span><span class="n">occurs</span><span class="o">.</span><span class="n">number</span><span class="p">(</span><span class="n">aRow</span><span class="p">)</span>

    <span class="c">## logger.debug( &quot;{0} Exit  {1} size={2}*{3}={4}&quot;.format(</span>
    <span class="c">##     &quot;&lt;&quot;*aDDE.indent, aDDE, aDDE.size, aDDE.occurs.number(aRow), aDDE.totalSize) )</span>
</pre></div>
</div>
<p>This function can be used during DDE load time if there are no Occurs Depending On.
Otherwise, it must be used for each individual row which is read.
See <a class="reference internal" href="sheet.html#sheet.LazyRow" title="sheet.LazyRow"><tt class="xref py py-class docutils literal"><span class="pre">sheet.LazyRow</span></tt></a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/Stingray_belon1553_small.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">10.2.3. COBOL Definitions Module &#8211; Handle COBOL DDE&#8217;s</a><ul>
<li><a class="reference internal" href="#the-architecture-problem">10.2.3.1. The Architecture Problem</a><ul>
<li><a class="reference internal" href="#where-to-recompute">10.2.3.1.1. Where To Recompute</a></li>
<li><a class="reference internal" href="#the-module-dependency-problem">10.2.3.1.2. The Module Dependency Problem</a></li>
<li><a class="reference internal" href="#resolution">10.2.3.1.3. Resolution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overheads">10.2.3.2. Overheads</a></li>
<li><a class="reference internal" href="#exception">10.2.3.3. Exception</a></li>
<li><a class="reference internal" href="#cell-subclasses-and-conversions">10.2.3.4. Cell Subclasses and Conversions</a></li>
<li><a class="reference internal" href="#essential-class-definitions">10.2.3.5. Essential Class Definitions</a><ul>
<li><a class="reference internal" href="#usage-strategy-hierarchy">10.2.3.5.1. Usage Strategy Hierarchy</a></li>
<li><a class="reference internal" href="#allocation-strategy-hierarchy">10.2.3.5.2. Allocation Strategy Hierarchy</a></li>
<li><a class="reference internal" href="#occurs-strategy-hierarchy">10.2.3.5.3. Occurs Strategy Hierarchy</a></li>
<li><a class="reference internal" href="#dde-class">10.2.3.5.4. DDE Class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dde-preparation-processing">10.2.3.6. DDE Preparation Processing</a></li>
<li><a class="reference internal" href="#set-size-and-offset">10.2.3.7. Set Size and Offset</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="cobol_loader.html"
                        title="previous chapter">10.2.2. COBOL Loader Module &#8211; Parse COBOL Source to Load a Schema</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="developer.html"
                        title="next chapter">11. The <strong>Stingray</strong> Developer&#8217;s Guide</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/cobol_defs.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="developer.html" title="11. The Stingray Developer’s Guide"
             >next</a> |</li>
        <li class="right" >
          <a href="cobol_loader.html" title="10.2.2. COBOL Loader Module – Parse COBOL Source to Load a Schema"
             >previous</a> |</li>
        <li><a href="index.html">The Stingray Schema-Based File Reader</a> &raquo;</li>
          <li><a href="cobol.html" >10. The COBOL Package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, S. Lott.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>